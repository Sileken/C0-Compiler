/*
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 * This sourcecode does nothing useful, execpt the         *
 * demonstration of successfully parsing C0--              *
 * Run at your own risk!                                   *
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 */

struct s1rukture {
    int number;
    int[] numbers;
    bool isUseful;
    void* point2someMemory;
};

struct unsignedInteger {
    int mostSignificant;
    int leastSignificant;
};

int eat(bool exitPoint, int* boolean);
void* sleep(int rest);
void code(int* x, bool y);
struct s1rukture createSomething();
void move(int from, int buffer, int to, int size);
struct unsignedInteger add(struct unsignedInteger uI1, struct unsignedInteger uI2);
struct unsignedInteger sub(struct unsignedInteger uI1, struct unsignedInteger uI2);

int main() {
    
    bool tired = false;
    int* exitPoint; 
    int NSA = eat(tired, exitPoint);

    struct s1rukture hodor = createSomething();
    hodor.isUseful = true;
    hodor->numbers[0] = 1333;

    move(1, 2, 3, 5);

    struct unsignedInteger uInt1 = alloc(struct unsignedInteger);
    struct unsignedInteger uInt2 = alloc(struct unsignedInteger);
    struct unsignedInteger uInt3 = alloc(struct unsignedInteger);

    uInt1->mostSignificant = 0;
    uInt1->leastSignificant = 2000000000;
    uInt2->mostSignificant = 0;
    uInt2->leastSignificant = 1000000000;

    uInt3 = add(uInt1, uInt2);

    return 1;
}

int eat(bool exitPoint, int* boolean) {
    *boolean = 4711;
    int* source = alloc(int);
    *source = 0;
    
    if (!exitPoint && true) {
        while (boolean <= 4747) {
            (*boolean)++;
            sleep(*boolean);
            code(source, exitPoint);
            // repeat!
        }

        return *source;
    }
    else {
        return -1;
    }
}

void* sleep(int rest) {
    return NULL;
}

void code(int* x, bool y) {
    if (y || *x - (*x / 31415) >= 0xBABE) {
        *x = *x * (*x/2);
    }
    *x = (*x < 1337  || !y) ? *x + 0b0101010 : *x + (999 - 666) * 2;

    return;
}

struct s1rukture createSomething() {
    struct s1rukture ss7 = alloc(struct s1rukture);
    ss7->number = 1337;
    ss7->numbers = alloc_array(int, 42);
    ss7->isUseful = false;
    ss7->point2someMemory = 0x10CAFFEE;

    return ss7;
}

void move (int from, int buffer, int to, int size)
{
    if (n == 1) {
        return;

    } else {
        move(from, to, buffer, size-1);
        move(from, buffer, to, 1);
        move(buffer, from, to, size-1);
    }
}

struct unsignedInteger add(struct unsignedInteger uI1, struct unsignedInteger uI2) {
    // toDo two's complement calculation ?
}

struct unsignedInteger sub(struct unsignedInteger uI1, struct unsignedInteger uI2) {
    // toDo
}

/* 
  ______                       _  _                   ______                                                       _               
 / _____)                     (_)| |                 / _____)                     _                          _    (_)              
| /        ___   ____   ____   _ | |  ____   ____   | /        ___   ____    ___ | |_    ____  _   _   ____ | |_   _   ___   ____  
| |       / _ \ |    \ |  _ \ | || | / _  ) / ___)  | |       / _ \ |  _ \  /___)|  _)  / ___)| | | | / ___)|  _) | | / _ \ |  _ \ 
| \_____ | |_| || | | || | | || || |( (/ / | |      | \_____ | |_| || | | ||___ || |__ | |    | |_| |( (___ | |__ | || |_| || | | |
 \______) \___/ |_|_|_|| ||_/ |_||_| \____)|_|       \______) \___/ |_| |_|(___/  \___)|_|     \____| \____) \___)|_| \___/ |_| |_|
                       |_|                                                                                                         

   ____   ____        ___   ___   ___ ____
  / __/  / __/       |_  | / _ \ <  //_  /
 _\ \   _\ \        / __/ / // / / /  / / 
/___/  /___/       /____/ \___/ /_/  /_/  


  _____    _____   _____        _____    __   ___    _____      __      _ 
 / ____\  (_   _) (_   _)      / ___/   () ) / __)  / ___/     /  \    / )
( (___      | |     | |       ( (__     ( (_/ /    ( (__      / /\ \  / / 
 \___ \     | |     | |        ) __)    ()   (      ) __)     ) ) ) ) ) ) 
     ) )    | |     | |   __  ( (       () /\ \    ( (       ( ( ( ( ( (  
 ___/ /    _| |__ __| |___) )  \ \___   ( (  \ \    \ \___   / /  \ \/ /  
/____/    /_____( \________/    \____\  ()_)  \_\    \____\ (_/    \__/   
                                                                          

___________                              __               ____ 
\__    ___/ __  _  __ _____      ____   |  | __   ______ /_   |
  |    |    \ \/ \/ / \__  \    /    \  |  |/ /  /  ___/  |   |
  |    |     \     /   / __ \_ |   |  \ |    <   \___ \   |   |
  |____|      \/\_/   (____  / |___|  / |__|_ \ /____  >  |___|
                           \/       \/       \/      \/        

   __         _                _               
  / /    ___ | |  __ _  _ __  | |_  _   _  ___ 
 / /    / _ \| | / _` || '_ \ | __|| | | |/ __|
/ /___ |  __/| || (_| || | | || |_ | |_| |\__ \
\____/  \___||_| \__,_||_| |_| \__| \__,_||___/                                                                     
                                        
*/