options {
  LOOKAHEAD = 15;
  CHOICE_AMBIGUITY_CHECK = 2;
  OTHER_AMBIGUITY_CHECK = 1;
  STATIC = true;
  DEBUG_PARSER = true;
  DEBUG_LOOKAHEAD = false;
  DEBUG_TOKEN_MANAGER = false;
  ERROR_REPORTING = true;
  JAVA_UNICODE_ESCAPE = false;
  UNICODE_INPUT = false;
  IGNORE_CASE = false;
  USER_TOKEN_MANAGER = false;
  USER_CHAR_STREAM = false;
  BUILD_PARSER = true;
  BUILD_TOKEN_MANAGER = true;
  SANITY_CHECK = true;
  FORCE_LA_CHECK = false;
}

PARSER_BEGIN(C0Parser)

package parser;

import astnodes.*;

public class C0Parser {
}

PARSER_END(C0Parser)

/************************************************
 *        TOKEN SPECIFICATION STARTS HERE       *
 ************************************************/

SKIP :
{
  " "
| "\t"
| "\n"
| "\r"
}

/* RESERVED WORDS: Page 15 C0-Ref */
TOKEN :
{
  < INT: "int" >
| < BOOL: "bool" >
| < STRING: "string" >
| < CHAR: "char" >
| < VOID: "void" >
| < STRUCT: "struct" >
| < IF: "if" >
| < ELSE: "else" >
| < WHILE: "while" >
| < FOR: "for" >
| < CONTINUE: "continue" >
| < BREAK: "break" >
| < RETURN: "return" >
| < TRUE: "true" >
| < FALSE: "false" >
| < NULL: "NULL" >
| < ALLOC: "alloc" >
| < ALLOC_ARRAY: "alloc_array" >
}

/* SEPARATORS */
TOKEN :
{
  < LPAREN: "(" >
| < RPAREN: ")" >
| < LBRACE: "{" >
| < RBRACE: "}" >
| < LBRACKET: "[" >
| < RBRACKET: "]" >
| < SEMICOLON: ";" >
| < COMMA: "," >
| < DOT: "." >
| < FIELD_DEREF: "->" >
}

/* OPERATORS: Page 18 C0-Ref */
TOKEN : 
{
  < BANG: "!" >
| < TILDE: "~" >
| < STAR: "*" >
| < INCR: "++" >
| < DECR: "--" >
| < SLASH: "/" >
| < REM: "%" >
| < PLUS: "+" >
| < MINUS: "-" >
| < LSHIFT: "<<" >
| < RSHIFT: ">>" >
| < LT: "<" >
| < LE: "<=" >
| < GE: ">=" >
| < GT: ">" >
| < EQ: "==" >
| < NE: "!=" >
| < BIT_AND: "&" >
| < XOR: "^" >
| < BIT_OR: "|" >
| < SC_AND: "&&" >
| < SC_OR: "||" >
| < HOOK: "?" >
| < COLON: ":" >
| < ASSIGN: "=" >
| < PLUSASSIGN: "+=" >
| < MINUSASSIGN: "-=" >
| < STARASSIGN: "*=" >
| < SLASHASSIGN: "/=" >
| < REMASSIGN: "%=" >
| < ANDASSIGN: "&=" >
| < XORASSIGN: "^=" >
| < ORASSIGN: "|=" >
| < LSHIFTASSIGN: "<<=" >
| < RSHIFTASSIGN: ">>=" >
}

/* LITERALS */
TOKEN : 
{
  < INTEGER_LITERAL:
        <DECIMAL_LITERAL>
      | <HEX_LITERAL> 
  >
|
  < #DECIMAL_LITERAL: "0" | ["1"-"9"] (["0"-"9"])* >
|
  < #HEX_LITERAL: "0" ["x","X"] (["0"-"9","a"-"f","A"-"F"])+ >
}

/* Char's + String's */
TOKEN :
{
  < CHAR_LITERAL: "'" (~["\r", "\n", "\t", "'", "\\"] | "\\0") "'" > // Should empty ' ' allowed? e.g. char c = ' '. For now it is
// | < STRING_LITERAL: "\"" (~["\r", "\n", "\t", "\"", "\\"] | "\\\"" | "\\\\" )* "\"" > // Hard to understand, so i splitted it
}

MORE :
{
  < STRING_BEGIN: "\"" > : IN_STRING_LITERAL 
}

<IN_STRING_LITERAL> TOKEN :
{
  <STRING_LITERAL: "\""> : DEFAULT
}

<IN_STRING_LITERAL> MORE :
{
 <~["\r", "\n", "\t", "\"", "\\"]> // every character except those in brackets
| "\\n"  // \n
| "\\t"  // \t
| "\\v"  // \v
| "\\b"  // \b
| "\\r"  // \r
| "\\f"  // \f
| "\\a"  // \a
| "\\\\" // \\
| "\\'"  // \'
| "\\\"" // \"
}

/* Identifiers */
TOKEN [IGNORE_CASE] :
{
  < IDENTIFIER: ["a"-"z"] ( ["a"-"z"] | ["0"-"9"] | "_")* >
}

/* COMMENTS */
SKIP :
{
  < "//" (~["\r", "\n"])* >
|
  < "/*" > : MULTI_LINE_COMMENT
}

<MULTI_LINE_COMMENT> SKIP :
{
  < "*/" > : DEFAULT
| < ~[] > // ~[] = all characters
}

/************************************************
 * THE C0 GRAMMAR SPECIFICATION STARTS HERE *
 ************************************************/

Node parseTree() :
{
  Node rootNode = new Node();
}
{
  //global Sachen parsen <prog> (globale Deklarationen und globale Funktionen)
  // Danach Statements, die expression usw.
  
  prog() <EOF> 
  {
     return rootNode;
  }
}

void prog() :
{}
{
  (GDECL() | GDEFN())* 
}

///////////////////////////////////////
/////    Different Identifiers    /////
///////////////////////////////////////

// Is it important to make a distinction?

// For variable + function names
void VID() :
{}
{
  <IDENTIFIER>
}

// Structnames
void SID() :
{}
{
  <IDENTIFIER>
}

// Field names
void FID() :
{}
{
  <IDENTIFIER>
}

///////////////////////////////////////
/////         Data-Types          /////
///////////////////////////////////////

void Struct() :
{}
{
  <STRUCT> SID()
}

void PrimitiveType() :
{}
{
  <INT>
| <BOOL>
| <STRING>
| <CHAR>
| <VOID>
}

void Type() :
{}
{
  (PrimitiveType() | Struct()) [<STAR> | <LBRACKET> <RBRACKET>] // Pointers + Arrays optional e.g. struct Test*, struct Test[], int*, string
}

///////////////////////////////////////
/////          L-Value            /////
///////////////////////////////////////

// Examples are: *test, test.data, test->data, (test)
void Lv() :
{}
{ 
  [<STAR>] VID() [<DOT> FID() | <FIELD_DEREF> FID() | (<LBRACKET> Expression() <RBRACKET>)] 
| <LPAREN> Lv() <RPAREN>
}

///////////////////////////////////////
/////        Operators            /////
///////////////////////////////////////

// Page 15 C0-Reference - Can we transfer those to the lexer?
void Sep() :
{}
{
  <LPAREN>
| <RPAREN>
| <LBRACKET>
| <RBRACKET>
| <LBRACE>
| <RBRACE>
| <COMMA>
| <SEMICOLON>
}

void UnaryOp() :
{}
{
  <BANG>
| <TILDE>
| <MINUS>
| <STAR>
}

void BinaryOp() :
{}
{
  <STAR>
| <SLASH>
| <REM>
| <PLUS>
| <MINUS>
| <LSHIFT>
| <RSHIFT>
| <LT>
| <LE>
| <GE>
| <GT>
| <EQ>
| <NE>
| <BIT_AND>
| <XOR>
| <BIT_OR>
| <SC_AND>
| <SC_OR>
//| <DOT>         // How is this a binary expression? LOOKAHEAD of 2 is necessary if these are specified
//| <FIELD_DEREF> // How is this a binary expression?
//| <HOOK>        // How is this a binary expression?
//| <COLON>       // How is this a binary expression?
}

void AsnOp() :
{}
{
  <ASSIGN>
| <PLUSASSIGN>
| <MINUSASSIGN>
| <STARASSIGN>
| <SLASHASSIGN>
| <REMASSIGN>
| <LSHIFTASSIGN>
| <RSHIFTASSIGN>
| <ANDASSIGN>
| <XORASSIGN>
| <ORASSIGN>
}

void PostOp() :
{}
{
  <DECR> | <INCR>
}

///////////////////////////////////////
/////        Expressions          /////
///////////////////////////////////////

// THIS IS NOT OPTIMAL. BEST WOULD BE TO USE LOCAL LOOKAHEADS AND MAKE THE GLOBAL LOOKAHEAD SMALLER
void Expression() :
{}
{
  (
  <LPAREN> Expression() <RPAREN>
| <INTEGER_LITERAL> | <STRING_LITERAL> | <CHAR_LITERAL>
| <TRUE> | <FALSE> | <NULL>
| VID() [<LPAREN> [ Expression() (<COMMA> Expression())* ] <RPAREN>]
| UnaryOp() Expression()
| <ALLOC> <LPAREN> Type() <RPAREN>
| <ALLOC_ARRAY> <LPAREN> Type() <COMMA> Expression() <RPAREN>
  )

  [
//  BinaryOp() Expression() | // Putting this again below allows to parse expressions like k[] = 3
    <HOOK> Expression() <COLON> Expression()  // e.g. 3 > 5 ? true : false
  | <DOT> FID()                               // Expression() <DOT> FID()
  | <FIELD_DEREF> FID()                       // Expression() <FIELD_DEREF> FID()
  | <LBRACKET> Expression() <RBRACKET>        // Expression() [ Expression() ]
  ]
  [
    BinaryOp() Expression()                   // Expression() BinaryOp() Expression()
  ]
}

///////////////////////////////////////
/////          Simple             /////
///////////////////////////////////////

void Simple() :
{}
{
  Lv() AsnOp() Expression()
| Lv() PostOp()
| Expression()
| Type() VID() [ <ASSIGN> Expression() ]
}

///////////////////////////////////////
/////          Stmt               /////
///////////////////////////////////////

void STMT() :
{}
{
  Simple() <SEMICOLON>
| <IF> <LPAREN> Expression() <RPAREN> STMT() [<ELSE> STMT()]
| <WHILE> <LPAREN> Expression() <RPAREN> STMT()
| <FOR> <LPAREN> [Simple()] <SEMICOLON> Expression() <SEMICOLON> [Simple()] <RPAREN> STMT()
| <RETURN> [Expression()] <SEMICOLON>
| <LBRACE> (STMT())* <RBRACE>
}

///////////////////////////////////////
/////          GDEFN              /////
///////////////////////////////////////

void GDEFN() :
{}
{
  <STRUCT> SID() <LBRACE> (Type() FID() <SEMICOLON>)* <RBRACE> <SEMICOLON>
| Type() VID() <LPAREN> [Type() VID() (<COMMA> Type() VID())*] <RPAREN> <LBRACE> (STMT())* <RBRACE>
}

///////////////////////////////////////
/////          GDECL              /////
///////////////////////////////////////

void GDECL() :
{}
{
  <STRUCT> SID() <SEMICOLON>
| Type() VID() <LPAREN> [Type() VID() (<COMMA> Type() VID())*] <RPAREN> <SEMICOLON> 
}