options {
  LOOKAHEAD = 1;
  CHOICE_AMBIGUITY_CHECK = 2;
  OTHER_AMBIGUITY_CHECK = 1;
  STATIC = true;
  DEBUG_PARSER = false;
  DEBUG_LOOKAHEAD = false;
  DEBUG_TOKEN_MANAGER = false;
  ERROR_REPORTING = true;
  JAVA_UNICODE_ESCAPE = false;
  UNICODE_INPUT = false;
  IGNORE_CASE = false;
  USER_TOKEN_MANAGER = false;
  USER_CHAR_STREAM = false;
  BUILD_PARSER = true;
  BUILD_TOKEN_MANAGER = true;
  SANITY_CHECK = true;
  FORCE_LA_CHECK = false;
}

PARSER_BEGIN(C0Parser)

package parser;

import java.util.ArrayList;
import java.util.List;

import ast.*;
import ast.declaration.*;
import ast.definition.*;
import ast.expression.*;
import ast.expression.primary.*;
import ast.expression.primary.name.*;
import ast.identifier.*;
import ast.statement.*;
import ast.type.*;

public class C0Parser {
}

PARSER_END(C0Parser)

/************************************************
 *        TOKEN SPECIFICATION STARTS HERE       *
 ************************************************/

SKIP :
{
    " "
  | "\t"
  | "\n"
  | "\r"
}

/* RESERVED WORDS: Page 15 C0-Ref */
TOKEN :
{
    < INT: "int" >
  | < BOOL: "bool" >
  | < VOID: "void" >
  | < STRUCT: "struct" >
  | < IF: "if" >
  | < ELSE: "else" >
  | < WHILE: "while" >
  | < FOR: "for" >
  | < CONTINUE: "continue" >
  | < BREAK: "break" >
  | < RETURN: "return" >
  | < TRUE: "true" >
  | < FALSE: "false" >
  | < NULL: "NULL" >
  | < ALLOC: "alloc" >
  | < ALLOC_ARRAY: "alloc_array" >
}

/* SEPARATORS */
TOKEN :
{
    < LPAREN: "(" >
  | < RPAREN: ")" >
  | < LBRACE: "{" >
  | < RBRACE: "}" >
  | < LBRACKET: "[" >
  | < RBRACKET: "]" >
  | < SEMICOLON: ";" >
  | < COMMA: "," >
  | < DOT: "." >
  | < FIELD_DEREF: "->" >
}

/* OPERATORS: Page 18 C0-Ref */
TOKEN : 
{
    < BANG: "!" >
  | < TILDE: "~" >
  | < STAR: "*" >
  | < INCR: "++" >
  | < DECR: "--" >
  | < SLASH: "/" >
  | < REM: "%" >
  | < PLUS: "+" >
  | < MINUS: "-" >
  | < LT: "<" >
  | < LEQ: "<=" >
  | < GEQ: ">=" >
  | < GT: ">" >
  | < EQ: "==" >
  | < NEQ: "!=" >
  | < BXOR: "^" >
  | < AND: "&&" >
  | < BAND: "&" >
  | < OR: "||" >
  | < BOR: "|" >
  | < HOOK: "?" >
  | < COLON: ":" >
  | < ASSIGN: "=" >
  | < PLUSASSIGN: "+=" >
  | < MINUSASSIGN: "-=" >
  | < STARASSIGN: "*=" >
  | < SLASHASSIGN: "/=" >
  | < REMASSIGN: "%=" >
  | < ANDASSIGN: "&=" >
  | < XORASSIGN: "^=" >
  | < ORASSIGN: "|=" >
}

/* LITERALS */
TOKEN : 
{
  < INTEGER_LITERAL:
        <DECIMAL_LITERAL>
      | <HEX_LITERAL> 
      | <BIN_LITERAL>
  >
  | < #DECIMAL_LITERAL: "0" | ["1"-"9"] (["0"-"9"])* >
  | < #HEX_LITERAL: "0" ["x","X"] (["0"-"9","a"-"f","A"-"F"])+ >
  | < #BIN_LITERAL: "0" ["b","B"] (["0"-"1"])+ >
}

MORE :
{
  < STRING_BEGIN: "\"" > : IN_STRING_LITERAL 
}

<IN_STRING_LITERAL> TOKEN :
{
  <STRING_LITERAL: "\""> : DEFAULT
}

<IN_STRING_LITERAL> MORE :
{
  <~["\r", "\n", "\t", "\"", "\\"]> // every character except those in brackets
  | "\\n"  // \n
  | "\\t"  // \t
  | "\\v"  // \v
  | "\\b"  // \b
  | "\\r"  // \r
  | "\\f"  // \f
  | "\\a"  // \a
  | "\\\\" // \\
  | "\\'"  // \'
  | "\\\"" // \"
}

/* Identifiers */
TOKEN [IGNORE_CASE] :
{
  < IDENTIFIER: ["a"-"z"] ( ["a"-"z"] | ["0"-"9"] | "_")* >
}

/* COMMENTS */
SKIP :
{
  < "//" (~["\r", "\n"])* >
  | < "/*" > : MULTI_LINE_COMMENT
}

<MULTI_LINE_COMMENT> SKIP :
{
  < "*/" > : DEFAULT
  | < ~[] > // ~[] = all characters
}

/************************************************
 * THE C0 GRAMMAR SPECIFICATION STARTS HERE *
 ************************************************/

AST parseTree() :
{
  FileUnit rootNode; 
}
{
  rootNode = prog() <EOF> 
  {
    AST ast = new AST();
    ast.setRoot(rootNode);
    System.out.println("C0 Compiler: Parsing finished");
    System.out.println("C0 Compiler: Abstract syntax tree constructed");  
    return ast;
  }
}

FileUnit prog() :
{
  List<Declaration> globalDeclarations = new ArrayList<Declaration>();
  List<Definition> globalDefinitions = new ArrayList<Definition>();
}
{
  (
     // Syntactic-Lookahead, JavaCC will try this out and if it not matches it will take the other choice (in this case a definition)
     // This is necessary because the amount of parameters can be infinite e.g. void func(int a, int b, ..., int n);
    LOOKAHEAD(GDECL())
    { Declaration decl; }
    decl = GDECL()
    { globalDeclarations.add(decl); }    
    | 
    { Definition def; } 
    def = GDEFN()
    { globalDefinitions.add(def); }
  )* 
  { 
     return new FileUnit(globalDeclarations, globalDefinitions); 
  }
}

///////////////////////////////////////
/////    Different Identifiers    /////
///////////////////////////////////////

VariableFunctionIdentifier VID() :
{ Token token; }
{
  token = <IDENTIFIER>
  { return new VariableFunctionIdentifier(token); } 
}

ParameterIdentifier PARAID() :
{ Token token; }
{
  token = <IDENTIFIER>
  { return new ParameterIdentifier(token); } 
}

StructIdentifier SID() :
{ Token token; }
{
  token = <IDENTIFIER>
  { return new StructIdentifier(token); }
}

FieldIdentifier FID() :
{ Token token; }
{
  token = <IDENTIFIER>
  { return new FieldIdentifier(token); }
}

///////////////////////////////////////
/////         Data-Types          /////
///////////////////////////////////////

StructType Struct() :
{ StructIdentifier structId; }
{
  <STRUCT> structId = SID()
  { return new StructType(structId); }
}

PrimitiveType PrimitiveType() :
{ Token token; }
{
  (
      token = <INT>
    | token = <BOOL>
    | token = <VOID>
  )
  { return new PrimitiveType(token.image); }
}

Type Type() :
{ Type type; }
{    
  (
    (  
      type = PrimitiveType() 
      | 
      type = Struct()
    )
    (
      <STAR> //Pointer
      { type = new ReferenceType(type); }
      | 
      <LBRACKET> <RBRACKET> // Array
      { type = new ArrayType(type); }      
    )*
  )
  { return type; } 
}

///////////////////////////////////////
/////        Operators            /////
///////////////////////////////////////

Token AssignmentOperator() :
{ Token token; }
{
  (
    token = <ASSIGN>
    | token = <PLUSASSIGN>
    | token = <MINUSASSIGN>
    | token = <STARASSIGN>
    | token = <SLASHASSIGN>
    | token = <REMASSIGN>
    | token = <ANDASSIGN>
    | token = <XORASSIGN>
    | token = <ORASSIGN>
  )
  { return token; }
}

///////////////////////////////////////
/////        Expressions          /////
///////////////////////////////////////

Expression Expression() :
{ Expression expression; }
{
  (
    expression = AllocExpression()
  |  
    LOOKAHEAD( PrimaryExpression() AssignmentOperator() )
    expression = Assignment()
  | 
    expression = ConditionalExpression()
  )
  { return expression; }
}

AllocExpression AllocExpression() :
{
  AllocExpression allocExp;
  Type type;
}
{
  (
      <ALLOC> <LPAREN> type = Type() <RPAREN>
      { allocExp = new AllocExpression(type); }
    | 
      { Expression dimension; }
      <ALLOC_ARRAY> <LPAREN> type = Type() <COMMA> dimension = Expression() <RPAREN>
      { allocExp = new AllocExpression(type, dimension); }
  )
  { return allocExp; }
}

// <------------------------- OPERATORS -------------------------->

Expression ConditionalExpression() :
{
  boolean isConditional = false;
  Expression condition = null;
  Expression trueExpression = null;
  Expression falseExpression = null;
}
{
  condition = ConditionalOrExpression() 
  [ <HOOK> trueExpression = Expression() <COLON> falseExpression = Expression() { isConditional = true; } ]
  {
    return isConditional 
      ? new ConditionalExpression(condition, trueExpression, falseExpression)
      : condition;
  }
}

Expression ConditionalOrExpression() :
{
  boolean isOr = false;
  Expression leftExp = null;
  Expression rightExp = null;
}
{
  leftExp = ConditionalAndExpression() 
  ( <OR> { isOr = true; } rightExp = ConditionalAndExpression() )*
  {
    return isOr 
      ? new BinaryExpression(leftExp, BinaryExpression.Operator.OR, rightExp)
      : leftExp;
  }
}

Expression ConditionalAndExpression() :
{
  boolean isAnd = false;
  Expression leftExp = null;
  Expression rightExp = null;
}
{
  leftExp = InclusiveOrExpression() 
  ( <AND> { isAnd = true; } rightExp = InclusiveOrExpression() )*
  {
    return isAnd 
      ? new BinaryExpression(leftExp, BinaryExpression.Operator.AND, rightExp)
      : leftExp;
  }
}

Expression InclusiveOrExpression() :
{  
  boolean isInOr = false;
  Expression leftExp = null;
  Expression rightExp = null;
}
{
  leftExp = ExclusiveOrExpression() 
  ( <BOR> { isInOr = true; } rightExp = ExclusiveOrExpression() )*
  {
    return isInOr 
      ? new BinaryExpression(leftExp, BinaryExpression.Operator.BOR, rightExp)
      : leftExp;
  }
}

Expression ExclusiveOrExpression() :
{
  boolean isExOr = false;
  Expression leftExp = null;
  Expression rightExp = null;
}
{
  leftExp = AndExpression() 
  ( <BXOR> { isExOr = true; } rightExp = AndExpression() )*
  {
    return isExOr 
      ? new BinaryExpression(leftExp, BinaryExpression.Operator.BXOR, rightExp)
      : leftExp;
  }
}

Expression AndExpression() :
{
  boolean isBinAnd = false;
  Expression leftExp = null;
  Expression rightExp = null;
}
{
  leftExp = EqualityExpression() 
  ( <BAND> { isBinAnd = true; } rightExp = EqualityExpression() )*
  {
    return isBinAnd 
      ? new BinaryExpression(leftExp, BinaryExpression.Operator.BAND, rightExp)
      : leftExp;
  }
}

Expression EqualityExpression() :
{
  boolean isEQ = false;
  boolean isNEQ = false;
  Expression leftExp = null;
  Expression rightExp = null;
}
{
  leftExp = RelationalExpression() 
  ( ( <EQ> { isEQ = true; } | <NEQ> { isNEQ = true; } ) rightExp = RelationalExpression() )*
  {
    return isEQ 
      ? new BinaryExpression(leftExp, BinaryExpression.Operator.EQ, rightExp)
      : isNEQ 
        ? new BinaryExpression(leftExp, BinaryExpression.Operator.NEQ, rightExp)
        : leftExp;
  }
}

Expression RelationalExpression() :
{
  boolean isLT = false;
  boolean isGT = false;
  boolean isLEQ = false;
  boolean isGEQ = false;
  Expression leftExp = null;
  Expression rightExp = null;
}
{
  leftExp = AdditiveExpression() 
  ( ( <LT> { isLT = true; } | <GT> { isGT = true; } | <LEQ> { isLEQ = true; } | <GEQ> { isGEQ = true; } ) rightExp = AdditiveExpression() )*
  {
    return isLT 
      ? new BinaryExpression(leftExp, BinaryExpression.Operator.LT, rightExp)
      : isGT 
        ? new BinaryExpression(leftExp, BinaryExpression.Operator.GT, rightExp)
        : isLEQ 
          ? new BinaryExpression(leftExp, BinaryExpression.Operator.LEQ, rightExp)
          : isGEQ 
            ? new BinaryExpression(leftExp, BinaryExpression.Operator.GEQ, rightExp)
            : leftExp;
  }
}

Expression AdditiveExpression() :
{
  boolean isPlus = false;
  boolean isMinus = false;
  Expression leftExp = null;
  Expression rightExp = null;
}
{
  leftExp = MultiplicativeExpression() 
  ( ( <PLUS> { isPlus = true; } | <MINUS> { isMinus = true; } ) rightExp = MultiplicativeExpression() )*
  {
    return isPlus 
      ? new BinaryExpression(leftExp, BinaryExpression.Operator.PLUS, rightExp)
      : isMinus 
        ? new BinaryExpression(leftExp, BinaryExpression.Operator.MINUS, rightExp)
        : leftExp;
  }
}

Expression MultiplicativeExpression() :
{
  boolean isMul = false;
  boolean isDiv = false;
  boolean isRem = false;
  Expression leftExp = null;
  Expression rightExp = null;
}
{
  leftExp = UnaryExpression() 
  ( ( <STAR> { isMul = true; } | <SLASH> { isDiv = true; } | <REM> { isRem = true; } ) rightExp = UnaryExpression() )*
  {
    return isMul 
      ? new BinaryExpression(leftExp, BinaryExpression.Operator.STAR, rightExp)
      : isDiv 
        ? new BinaryExpression(leftExp, BinaryExpression.Operator.SLASH, rightExp)
        : isRem 
          ? new BinaryExpression(leftExp, BinaryExpression.Operator.REM, rightExp)
          : leftExp;
  }
}

Expression UnaryExpression() :
{
  boolean isLogicalNot = false;
  boolean isBinNot = false;
  Expression exp = null;
}
{
  ( 
    <BANG> { isLogicalNot = true; } 
    | <TILDE> { isBinNot = true; } 
    | <MINUS>
  ) exp = UnaryExpression()
  {
    return isLogicalNot 
      ? new UnaryExpression(exp, UnaryExpression.Operator.BANG)
      : isBinNot 
        ? new UnaryExpression(exp, UnaryExpression.Operator.TILDE)
        : new UnaryExpression(exp, UnaryExpression.Operator.MINUS);
  }
  |
  exp = PostfixExpression()
  {
    return exp;
  }
}

Expression PostfixExpression() :
{
  boolean isIncr = false;
  boolean isDecr = false;
  Primary primary = null;
}
{
  primary = PrimaryExpression() [ <INCR> { isIncr = true; } | <DECR> { isDecr = true; } ]
  {
    return isIncr 
      ? new UnaryExpression(primary, UnaryExpression.Operator.INCR)
      : isDecr 
        ? new UnaryExpression(primary, UnaryExpression.Operator.DECR)
        : primary;
  }
}

// <------------------------- ASSIGNMENT -------------------------->

AssignmentExpression Assignment() :
{
  Expression leftExp;
  Token assignOperatorToken;
  Expression rightAssignExp;
}
{
  leftExp = PrimaryExpression() assignOperatorToken = AssignmentOperator() rightAssignExp = Expression()
  { return new AssignmentExpression(leftExp, AssignmentExpression.parseOperator(assignOperatorToken), rightAssignExp); }
}

Primary PrimaryExpression() :
{
  Primary prefix;
  List<Primary> suffixes = new ArrayList<Primary>();
  Primary suffix = null;
}
{
  prefix = PrimaryPrefix() 
  (
    suffix = PrimarySuffix() 
    { suffixes.add(suffix); } 
  )*
  { 
    // If we have several suffixes we have to recursively build up the tree in java-code
    if(!suffixes.isEmpty())
    {
      // Start on the last suffix so it is on the top of the tree
      suffix = suffixes.get(suffixes.size() - 1);
      suffix.addSuffixes(prefix, suffixes);
    }

    return suffix == null ? prefix : suffix; 
  }
}

Primary PrimaryPrefix() :
{ 
  Primary primary;
  boolean isDeref = false;
  double derefCount = 0;
}
{
  (
      primary = Literal()
    |
    (
      (
        <STAR>
        {
          isDeref = true;		
          derefCount += 1;
        }
      )*
      (
        { VariableFunctionIdentifier identifier; }
        identifier = VID()
        { primary = new SimpleName(identifier); }
      |
        { Expression expression; }
        <LPAREN> expression = Expression() <RPAREN>
        { primary = new ExpressionPrimary(expression); }
      )
    )
  )
  { 
    if( isDeref && derefCount > 0 ) {
      Expression currentPrimary = primary;

      for(int i=0; i < derefCount; i++){		
        currentPrimary = new UnaryExpression(currentPrimary, UnaryExpression.Operator.STAR);		
      }

      primary = new ExpressionPrimary(currentPrimary);
    }
    
    return primary; 
  }
}

Primary PrimarySuffix() :
{
  Primary primary;
  FieldIdentifier fieldId;
}
{
  (
      { Expression expression; }
      <LBRACKET> expression = Expression() <RBRACKET>
      { primary = new ArrayAccess(expression); }
    |
      <DOT> fieldId = FID()
      { primary = new FieldAccess(fieldId); }
    |
      <FIELD_DEREF> fieldId = FID()
      { primary = new FieldDereferenceAccess(fieldId); }
    |
      { List<Expression> arguments; }
      arguments = Arguments()
      { primary = new ExpressionPrimary(new MethodInvokeExpression(arguments)); } 
  )
  { return primary; }
}

LiteralPrimary Literal() :
{
  Token token;
  LiteralPrimary.LiteralType type;
}
{
  (
      token = <INTEGER_LITERAL> { type = LiteralPrimary.LiteralType.INTLIT; }
    | token = <TRUE> { type = LiteralPrimary.LiteralType.BOOLLIT; }
    | token = <FALSE> { type = LiteralPrimary.LiteralType.BOOLLIT; }
    | token = <NULL> { type = LiteralPrimary.LiteralType.NULL; }  
  )
  { return new LiteralPrimary(type, token); }  
}

List<Expression> Arguments() :
{ List<Expression> arguments = new ArrayList<Expression>(); }
{
  <LPAREN> [ ArgumentList(arguments) ] <RPAREN>
  { return arguments; }
}

void ArgumentList(List<Expression> arguments) :
{ Expression argument; }
{
  argument = Expression() { arguments.add(argument); }
  ( <COMMA> argument = Expression() { arguments.add(argument); } )*
}

///////////////////////////////////////
/////          Statement          /////
///////////////////////////////////////

Statement Statement() :
{ Statement statement; }
{
  ( 
      statement = ExpressionStatement()
    | statement = IfStatement()   
    | statement = WhileStatement()   
    | statement = ForStatement()
    | statement = ReturnStatement()
    | statement = Block()
  )
  { return statement; }
}

ExpressionStatement ExpressionStatement() :
{ Expression expression; }
{
    expression = Expression() <SEMICOLON>
    { return new ExpressionStatement(expression); }
}

IfStatement IfStatement() :
{
  Expression condition;
  Statement ifStatement;
  ElseStatement elseStatement = null;
}
{
  <IF> <LPAREN> condition = Expression() <RPAREN> 
  ifStatement = Statement() 
  [
    // This is needed to prevent the warning. The grammar is correct but the parser will throw a warning. 
    // If you want to know why look at https://javacc.org/tutorials/lookahead (search for dangling-else)
    LOOKAHEAD(1) 
    <ELSE> 
    { Statement statement; }
    statement = Statement()
    { elseStatement = new ElseStatement(statement); }
  ]
  { return new IfStatement(condition, ifStatement, elseStatement); }
}

WhileStatement WhileStatement() :
{ Expression condition; }
{
  <WHILE> <LPAREN> condition = Expression() <RPAREN> Statement()
  { return new WhileStatement(condition); }
}

ForStatement ForStatement() :
{
  Expression initialization = null;
  Expression condition;
  Expression increment = null;
  Statement statement;
}
{
  (
    <FOR> <LPAREN> 
    [ initialization = ForInit()] <SEMICOLON>
    condition = Expression() <SEMICOLON>
    [ increment = Expression()] <RPAREN> 
    statement = Statement()
  )
  { return new ForStatement(initialization, condition, increment, statement); }
}

Expression ForInit() :
{ Expression expression; }
{
  (
    LOOKAHEAD(Type() <IDENTIFIER>)
    expression = VariableDeclarationExpression()
    |
    expression = Expression()
  )
  { return expression; }
}

ReturnStatement ReturnStatement() :
{ Expression expression = null; }
{
  <RETURN> [ expression = Expression() ] <SEMICOLON>
  { return new ReturnStatement(expression); }
}

Block Block() :
{ List<Statement> statements = new ArrayList<Statement>(); }
{
  (
    <LBRACE> 
      (
        { Statement statement; }
        statement = BlockStatement()
        { statements.add(statement); }
      )* 
    <RBRACE>
  )
  { return new Block(statements); }
}

Statement BlockStatement() :
{ Statement statement; }
{
  (
    LOOKAHEAD(Type() <IDENTIFIER>)
    { Expression expression; }
    expression = VariableDeclarationExpression() <SEMICOLON>
    { statement = new ExpressionStatement(expression); }
    |
    statement = Statement()
  )
  { return statement; }
}

Expression VariableDeclarationExpression() :
{
  Type type;
  VariableFunctionIdentifier variableId;
  boolean isAssignExp = false;
  AssignmentExpression assignExp = null;
  Expression rightAssignExp = null;
}
{
	type = Type() variableId = VID() [ <ASSIGN> rightAssignExp = Expression() { isAssignExp = true; } ] 
  {
    VariableDeclaration varDecl = new VariableDeclaration(type, variableId);
    return isAssignExp
      ? (Expression) new AssignmentExpression(varDecl, rightAssignExp)
      : (Expression) new VariableDeclarationExpression(varDecl);
  }
}

///////////////////////////////////////
/////     Global Definition       /////
///////////////////////////////////////

Definition GDEFN() :
{ Definition node; }
{
  ( 
    // struct id {...} -> struct definition ; 
    // struct id func() {...} -> function declaration
    LOOKAHEAD(3) 
    node = GlobalStructDefinition()
    | node = GlobalFunctionDefinition()
  )
  { return node; }
}

StructDefinition GlobalStructDefinition() :
{
  StructIdentifier structId;
  List<FieldDefinition> fieldDefs = new ArrayList<FieldDefinition>();
}
{
  (
    <STRUCT> structId = SID() <LBRACE> 
    (
      { FieldDefinition fieldDef; }
      fieldDef = FieldDefinition()
      { fieldDefs.add(fieldDef); }
    )* 
    <RBRACE> <SEMICOLON>
  )
  { return new StructDefinition(new StructType(structId), structId, fieldDefs); }
}

FieldDefinition FieldDefinition():
{
  Type fieldType;
  FieldIdentifier fieldId;
}
{
  fieldType = Type() fieldId = FID() <SEMICOLON>
  { return new FieldDefinition(fieldType, fieldId); }
}

FunctionDefinition GlobalFunctionDefinition() :
{
  Type returnType;
  VariableFunctionIdentifier funcId;
  List<ParameterDefinition> parameterDefs;
  Block block;
}
{
  (
    returnType = Type() funcId = VID() 
    <LPAREN> parameterDefs = ParameterDefinitions() <RPAREN> 
    block = Block()
  )
  { return new FunctionDefinition(returnType, funcId, parameterDefs, block); }
}

///////////////////////////////////////
/////      Global Declaration     /////
///////////////////////////////////////

Declaration GDECL() :
{ Declaration node; }
{
  (
     // struct id; -> struct declaration
     // struct id func(); -> function declaration ---- We need at least 3 TOKENS to make the right choice
    LOOKAHEAD(3)
    node = GlobalStructDeclaration()
    |
    node = GlobalFunctionDeclaration()
  )
  { return node; }
}

StructDeclaration GlobalStructDeclaration() :
{ StructIdentifier structId; }
{
  <STRUCT> structId = SID() <SEMICOLON>
  { return new StructDeclaration(new StructType(structId), structId); }
}

FunctionDeclaration GlobalFunctionDeclaration() :
{
  Type returnType;
  VariableFunctionIdentifier funcId;
  List<ParameterDefinition> parameterDefs;
}
{
  returnType = Type() funcId = VID() <LPAREN> parameterDefs = ParameterDefinitions() <RPAREN> <SEMICOLON>
  { return new FunctionDeclaration(returnType, funcId, parameterDefs); }
}

List<ParameterDefinition> ParameterDefinitions() :
{
  List<ParameterDefinition> parameterDefs = new ArrayList<ParameterDefinition>();
  Type firstParaType;
  ParameterIdentifier firstParaId;
}
{
  [ 
    firstParaType = Type() firstParaId = PARAID() 
    { parameterDefs.add(new ParameterDefinition(firstParaType, firstParaId)); } 
    (
      {   
        Type additionalParaType;
        ParameterIdentifier additionalParaId;         
      }
      <COMMA> additionalParaType = Type() additionalParaId = PARAID()
      { parameterDefs.add(new ParameterDefinition(additionalParaType, additionalParaId)); }
    )* 
  ]
  { return parameterDefs; }
}